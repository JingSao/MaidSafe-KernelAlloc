/* kernel_alloc.hpp
Provides a kernel memory allocator and manager
(C) 2014 MaidSafe Ltd.
File Created: Nov 2014


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "config.hpp"

#ifdef BOOST_KERNELALLOC_NEED_DEFINE

/*! \file kernel_alloc.hpp
 * \brief Defines the functionality provided by Boost.KernelAlloc
 */

BOOST_KERNELALLOC_V1_NAMESPACE_BEGIN

namespace detail
{
  template<class T, typename = decltype(*std::declval<T&>(), ++std::declval<T&>(), void())> struct is_rangeable { typedef T type; };
  template<class T, typename = decltype(*std::begin(std::declval<T>()), *std::end(std::declval<T>()), void())> struct is_container { typedef decltype(*std::begin(std::declval<T>())) type; };
}

class source;
typedef std::shared_ptr<source> source_ptr;

/*! \class allocation
 * \brief An allocation of memory in the kernel.
 * 
 * Note that the contents of an allocation are \b not necessarily discarded \b nor destroyed
 * on destruction. Instead the storage used by the allocation is recycled and made available
 * for subsequent allocations. Therefore if the allocation is particularly large, you might
 * consider setting the discard_on_free flag which will release any RAM resources on free or
 * even the destroy_on_free flag which will release all storage on free.
 *
 * Mapping an allocation takes a shared_ptr to the allocation, thus pinning it from being
 * destructed until the last map is unmapped.
 */
class BOOST_KERNELALLOC_DECL allocation : public std::enable_shared_from_this<allocation>
{
public:
  //! \brief A pointer to a map
  typedef void *pointer;
  //! \brief A const pointer to an allocation
  typedef const pointer const_pointer;
  //! \brief A size_t
  typedef size_t size_type;
  //! \brief A sequence of offsets and sizes to map or unmap
  struct map_t
  {
    pointer addr;     //!< The address of the mapping in the local process
    size_type offset; //!< The offset to map
    size_type length; //!< The amount to map
    error_code ec;    //!< Any error which occurred during the operation
    map_t() : addr(nullptr), offset(0), length(0) { }
    map_t(size_type _offset, size_type _length) : addr(nullptr), offset(_offset), length(_length) { }
  };
private:
  source *_source;
protected:
  size_type _size, _actualsize;
  allocation(source *p, size_type size) : _source(p), _size(size) { }
public:
  virtual ~allocation() {}
  

  //! \brief The source for this allocation
  source *source() const BOOST_NOEXCEPT { return _source; }
  
  //! \brief The size of the allocation
  size_type size() const BOOST_NOEXCEPT { return _size; }
  
  //! \brief The actual size of the allocation, you can resize to this without relocation.
  size_type actual_size() const BOOST_NOEXCEPT { return _actualsize; }
  
  //! \brief The maps of this allocation into the current process
  std::vector<map_t> maps() const BOOST_NOEXCEPT;
  
  //! \brief Tries to resize the allocation to \em newsize without relocation (and therefore maps are not disturbed), returning true if successful.
  virtual bool try_resize(size_type newsize) BOOST_NOEXCEPT
  {
    if(newsize<=_actualsize)
    {
      _size=newsize;
      return true;
    }
    return false;
  }

  /*! \brief Tries to resize the allocation to \em newsize with address relocation (and
  therefore no maps can exist). For most sources this is a zero memory copy operation.
  */
  virtual error_code resize(size_type newsize) BOOST_NOEXCEPT=0;
  
  /*! \name allocation_map
   * \brief Maps part of the allocation into the calling process. \em offset and \em length need to be valid.
   */
  //@{
  virtual size_type map(map_t *m, size_type no) BOOST_NOEXCEPT=0;
  //! \brief Optimisation for a single map_t
  bool map(map_t &m) BOOST_NOEXCEPT { return 1==map(&m, 1); }
  //! \brief For a range of dereferenceable pointers or iterators
  template<class T, typename=typename detail::is_rangeable<T>::type> size_type map(T &&begin, T &&end)
  {
    size_type ret=0;
    for(; begin!=end; ++begin)
      ret+=map(&(*begin()), 1);
    return ret;
  }
  //! \brief For a container
  template<class T, typename=typename detail::is_container<T>::type> size_type map(T &&cont)
  {
    return map(std::begin(std::forward<T>(cont)), std::end(std::forward<T>(cont)));
  }
  //! \brief Optimisation for a vector
  size_type map(const std::vector<map_t> &c)
  {
    return map(c.data(), c.size());
  }
  //! \brief Maps all of the allocation into the calling process
  map_t map() BOOST_NOEXCEPT
  {
    map_t m(0, size());
    map(&m, 1);
    return m;
  }
  //@}
  
  
  /*! \name allocation_map_prefault
   * \brief Maps and prefaults for reading part of the allocation into the calling process. \em offset and \em length need to be valid.
   * 
   * Normally when you allocate memory from the kernel each page is marked to page fault on first read or
   * write, so if working with N pages you see N page faults per read and potentially another N page faults per write,
   * each of which costs 500-5000 CPU cycles. Map and commit asks the kernel to do as much of the \em read
   * page faulting in the range as possible now. Note that the kernel is free to ignore or partially ignore
   * this request, and may in fact incompletely prefault pages into memory depending on a wide range of
   * operating system specific factors.
   */
  //@{
  virtual size_type map_prefault(map_t *m, size_type no) BOOST_NOEXCEPT=0;
  //! \brief Optimisation for a single map_t
  bool map_prefault(map_t &m) BOOST_NOEXCEPT { return 1==map_prefault(&m, 1); }
  //! \brief For a range of dereferenceable pointers or iterators
  template<class T, typename=typename detail::is_rangeable<T>::type> size_type map_prefault(T &&begin, T &&end)
  {
    size_type ret=0;
    for(; begin!=end; ++begin)
      ret+=map_prefault(&(*begin()), 1);
    return ret;
  }
  //! \brief For a container
  template<class T, typename=typename detail::is_container<T>::type> size_type map_prefault(T &&cont)
  {
    return map_prefault(std::begin(std::forward<T>(cont)), std::end(std::forward<T>(cont)));
  }
  //! \brief Optimisation for a vector
  size_type map_prefault(const std::vector<map_t> &c)
  {
    return map_prefault(c.data(), c.size());
  }
  //! \brief Maps all of the allocation into the calling process
  map_t map_prefault() BOOST_NOEXCEPT
  {
    map_t m(0, size());
    map_prefault(&m, 1);
    return m;
  }
  //@}
  
  
  /*! \name allocation_unmap
   * \brief Unmaps part of the allocation from the calling process. Requires \em addr to point to a valid map and \em length to be valid.
   */
  //@{
  virtual size_type unmap(map_t *m, size_type no) BOOST_NOEXCEPT=0;
  //! \brief Optimisation for a single map_t
  bool unmap(map_t &m) BOOST_NOEXCEPT { return 1==unmap(&m, 1); }
  //! \brief For a range of dereferenceable pointers or iterators
  template<class T, typename=typename detail::is_rangeable<T>::type> size_type unmap(T &&begin, T &&end)
  {
    size_type ret=0;
    for(; begin!=end; ++begin)
      ret+=unmap(&(*begin()), 1);
    return ret;
  }
  //! \brief For a container
  template<class T, typename=typename detail::is_container<T>::type> size_type unmap(T &&cont)
  {
    return map(std::begin(std::forward<T>(cont)), std::end(std::forward<T>(cont)));
  }
  //! \brief Optimisation for a vector
  size_type unmap(const std::vector<map_t> &c)
  {
    return unmap(c.data(), c.size());
  }
  //@}
  
  /*! \name allocation_discard
   * \brief Discards without saving any RAM resources associated with an existing map.
   * Requires \em addr to point to a valid map and \em length need to be valid.
   * 
   * This essentially returns a map to a state of being freshly just mapped in terms of use of kernel resources.
   * Note that the kernel is free to ignore or partially ignore this request, and may in fact incompletely
   * decommit storage such that the discarded pages become a mix of zeroed and non-zeroed pages.
   * 
   * If you routinely allocate buffers, use them and deallocate them, this is *exactly* the correct alternative.
   * Instead of deallocation-reallocation, discard their contents instead and reuse the allocation.
   */
  //@{
  virtual size_type discard(map_t *m, size_type no) BOOST_NOEXCEPT=0;
  //! \brief Optimisation for a single map_t
  bool discard(map_t &m) BOOST_NOEXCEPT { return 1==discard(&m, 1); }
  //! \brief For a range of dereferenceable pointers or iterators
  template<class T, typename=typename detail::is_rangeable<T>::type> size_type discard(T &&begin, T &&end)
  {
    size_type ret=0;
    for(; begin!=end; ++begin)
      ret+=discard(&(*begin()), 1);
    return ret;
  }
  //! \brief For a container
  template<class T, typename=typename detail::is_container<T>::type> size_type discard(T &&cont)
  {
    return discard(std::begin(std::forward<T>(cont)), std::end(std::forward<T>(cont)));
  }
  //! \brief Optimisation for a vector
  size_type discard(const std::vector<map_t> &c)
  {
    return discard(c.data(), c.size());
  }
  //@}

  /*! \name allocation_destroy
   * \brief Destroys the contents of the allocation between \em offset and \em length, releasing all storage
   * associated with that region.
   * 
   * Despite that the kernel is free to ignore or partially ignore this request, you are guaranteed that the region
   * specified will have its contents reset to zero. In practice, the storage backing the region will only
   * be freed if and when the kernel decides, which may be never in some situations.
   */
  //@{
  virtual size_type destroy(map_t *m, size_type no) BOOST_NOEXCEPT=0;
  //! \brief Optimisation for a single map_t
  bool destroy(map_t &m) BOOST_NOEXCEPT { return 1==destroy(&m, 1); }
  //! \brief For a range of dereferenceable pointers or iterators
  template<class T, typename=typename detail::is_rangeable<T>::type> size_type destroy(T &&begin, T &&end)
  {
    size_type ret=0;
    for(; begin!=end; ++begin)
      ret+=destroy(&(*begin()), 1);
    return ret;
  }
  //! \brief For a container
  template<class T, typename=typename detail::is_container<T>::type> size_type destroy(T &&cont)
  {
    return destroy(std::begin(std::forward<T>(cont)), std::end(std::forward<T>(cont)));
  }
  //! \brief Optimisation for a vector
  size_type destroy(const std::vector<map_t> &c)
  {
    return destroy(c.data(), c.size());
  }
  //@}

};

/*! \class source
 * \brief A source of kernel memory
 * 
 * Not only can one set a ceiling on the size of memory allocated, one can set a maximum total count
 * which is very useful for out of memory testing.
 *
 * Note that a source is intended as a single scatter gather DMA operation. You should therefore
 * allocate a source per scatter and per gather. The allocations from each source are equivalent
 * to individual buffers in a gather/scatter operation.
 *
 * Underlying resources behind a source are usually reset to default storage on destruction instead
 * of being actually destroyed, and kept on a ring buffer for fast construction.
 */
class BOOST_KERNELALLOC_DECL source : public std::enable_shared_from_this<source>
{
public:
  //! \brief Rebinds a pointer to a different type of allocation
  template<class T> using rebind_pointer = std::shared_ptr<T>;
  //! \brief A pointer to an allocation
  typedef rebind_pointer<allocation> pointer;
  //! \brief A const pointer to an allocation
  typedef const pointer const_pointer;
  //! \brief A size_t
  typedef size_t size_type;

  //! \brief Flags for this source
  enum class flags_t
  {
    normal=0,                   //!< No special behaviour
    discard_on_free=1,          //!< Issue a discard() when an allocation is about to be freed
    destroy_on_free=2,          //!< Issue a destroy() when an allocation is about to be freed
    top_down=(1<<16),           //!< Allocate from the top of memory going downwards (e.g. stacks)
    large_pages=(1<<17)         //!< Use large TLB entries where possible.
  };
protected:
  bool _using_remaining;
  size_type _maximum;
  atomic<size_type> _allocated, _remaining;
  source(flags_t flags, size_type maximum, size_type remaining) : _using_remaining((remaining!=(size_type)-1)), _maximum(maximum), _remaining(remaining) { }
  
  void _register_map(allocation *a, allocation::map_t &map);
  void _register_unmap(allocation *a, allocation::map_t &map);
public:
  
  //! \brief The maximum amount of memory this source can allocate
  size_type maximum() const BOOST_NOEXCEPT { return _maximum; }
  
  //! \brief The amount of memory currently allocated by this source
  size_type allocated() const BOOST_NOEXCEPT { return _allocated; }
  
  //! \brief The amount of memory remaining which this source can allocate
  size_type remaining() const BOOST_NOEXCEPT { return _remaining; }
  
  //! \brief The name of this source, suitable for printing etc.
  virtual const char *name() BOOST_NOEXCEPT=0;
  
  /*! \brief Allocates at least \em bytes from the source.
   */
  virtual expected<pointer, error_code> allocate(size_type bytes) BOOST_NOEXCEPT=0;
  
  /*! \brief Allocates a set of different sized allocations from the source in a single go.
   */
  virtual expected<std::vector<pointer>, error_code> allocate(size_type no, size_type *bytes) BOOST_NOEXCEPT=0;
  
  /*! \brief Returns the source and allocation associated with mapped address \em addr
   */
  static std::tuple<source_ptr, pointer, allocation::map_t> locate_addr(void *addr) BOOST_NOEXCEPT;
};

/*! \class nonpersistent_allocation
 * \brief An allocation of non persistent memory in the kernel.
 * 
 * This is generally the fastest kernel memory allocator, but comes with significant limitations:
 *  - All allocations are aligned to a page size boundary and are rounded up to page size multiples.
 *  - Cannot resize allocations except on Linux.
 *  - Only the map of offset zero to length will succeed.
 *  - Attempts to duplicate the map will return the existing map.
 *  - Contents are destroyed as soon as unmap is called.
 *  - Destroy is implemented as discard followed by a scan for non-zero bytes, and where found
 *    the non-zero page is zeroed.
 */
class BOOST_KERNELALLOC_DECL nonpersistent_allocation : public allocation
{
protected:
  allocation(nonpersistent_source *p, size_type bytes);
public:
  virtual ~nonpersistent_allocation() override final;
  
  virtual size_type map(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type map_prefault(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type unmap(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type discard(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type destroy(map_t *m, size_type no) BOOST_NOEXCEPT override final;
};

/*! \class nonpersistent_source
 * \brief A non-persistent source of kernel memory, usually the system page file.
 */
class BOOST_KERNELALLOC_DECL nonpersistent_source : public source
{
public:
  //! \brief A pointer to an allocation
  typedef rebind_pointer<nonpersistent_allocation> pointer;
  //! \brief A const pointer to an allocation
  typedef const pointer const_pointer;
  
  //! \brief Constructs a source of non persistent kernel memory.
  nonpersistent_source(flags_t flags=flags_t::normal, size_type maximum=(size_type)-1, size_type remaining=(size_type)-1) : source(flags, maximum, remaining) { }
  
  //! \brief The name of this source, suitable for printing etc.
  virtual const char *name() BOOST_NOEXCEPT override final { return "non-persistent"; }
  
  /*! \brief Allocates at least \em bytes from the source.
   */
  virtual expected<pointer, error_code> allocate(size_type bytes) BOOST_NOEXCEPT override final;
};


/*! \class opencl_allocation
 * \brief A non persistent allocation of memory in the graphics card.
 * 
 * This is very similar to nonpersistent_allocation with the same limitations.
 */
class BOOST_KERNELALLOC_DECL opencl_allocation : public allocation
{
protected:
  opencl_allocation(opencl_source *p, size_type bytes);
public:
  virtual ~opencl_allocation() override final;
  
  virtual size_type map(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type map_prefault(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type unmap(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type discard(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type destroy(map_t *m, size_type no) BOOST_NOEXCEPT override final;
};

/*! \class opencl_source
 * \brief A non-persistent source of kernel memory in the graphics card.
 */
class BOOST_KERNELALLOC_DECL opencl_source : public source
{
public:
  //! \brief A pointer to an allocation
  typedef rebind_pointer<opencl_allocation> pointer;
  //! \brief A const pointer to an allocation
  typedef const pointer const_pointer;
  
  //! \brief Constructs a source of non persistent kernel memory.
  opencl_source(flags_t flags=flags_t::normal, size_type maximum=(size_type)-1, size_type remaining=(size_type)-1) : source(flags, maximum, remaining) { }
  
  //! \brief The name of this source, suitable for printing etc.
  virtual const char *name() BOOST_NOEXCEPT override final { return "opencl"; }
  
  /*! \brief Allocates at least \em bytes from the source.
   */
  virtual expected<pointer, error_code> allocate(size_type bytes) BOOST_NOEXCEPT override final;
};


/*! \class persistent_allocation
 * \brief An allocation of persistent memory in the kernel, usually the temporary file system cache.
 * 
 * Unlike non persistent allocations, storage for persistent allocations is kept in the
 * temporary file system cache or equivalent. It therefore can persist until the next reboot
 * of the machine, and it offers the following features:
 *  - Allocations are aligned to the cache line boundary and are of cache line sized multiples.
 *    This is ideal for the DMA engine, whilst not wasting too much space for small allocations.
 *  - Maps of any part of the allocation into user space can be made, including duplicate maps and
 *    discontinuous maps.
 *  - Contents survive no maps existing, though remember to keep a shared_ptr open to the allocation
 *    if you wish its contents to be retained.
 *  - Resizing works as expected, and zero copy allocation expansion can be achieved by keeping allocation
 *    sizes to page size boundaries as additional storage is mapped in as page extensions during maps.
 *  - Persistent allocation sources can be named, and that name also used by other processes to see the same
 *    allocation. Simply ask the same named source for the allocation with the given unique id. Note you
 *    cannot resize an allocation shared with other processes.
 *  - Lets 32 bit processes use a lot more RAM than 4Gb. One must simply take care to not leave
 *    allocations mapped into memory lying around.
 */
class BOOST_KERNELALLOC_DECL persistent_allocation : public allocation
{
public:
  //! \brief The type of a unique allocation id
  typedef unsigned long long unique_id_t;
protected:
  unique_id_t _unique_id;
  persistent_allocation(nonpersistent_source *p, size_type bytes);
public:
  virtual ~persistent_allocation() override final;
  
  virtual size_type map(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type map_prefault(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type unmap(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type discard(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type destroy(map_t *m, size_type no) BOOST_NOEXCEPT override final;
    
  //! \brief The unique id of this persistent allocation within its source.
  unique_id_t unique_id() const BOOST_NOEXCEPT { return _unique_id; }

  //! \brief Resizes the allocation to a new size
  virtual error_code resize(size_type newsize) BOOST_NOEXCEPT override final;
};

/*! \class persistent_source
 * \brief A persistent source of kernel memory, usually the temporary file system cache.
 */
class BOOST_KERNELALLOC_DECL persistent_source : public source
{
public:
  //! \brief A pointer to an allocation
  typedef rebind_pointer<persistent_allocation> pointer;
  //! \brief A const pointer to an allocation
  typedef const pointer const_pointer;
  
  //! \brief Constructs a source of optionally named persistent kernel memory.
  persistent_source(path name=path(), flags_t flags=flags_t::normal, size_type maximum=(size_type)-1, size_type remaining=(size_type)-1) : source(maximum, remaining) { }
  
  //! \brief The name of this source, suitable for printing etc.
  virtual const char *name() BOOST_NOEXCEPT override final { return "persistent"; }
  
  /*! \brief Allocates at least \em bytes from the source, returning an empty pointer if unsuccessful
   */
  virtual expected<pointer, error_code> allocate(size_type bytes) BOOST_NOEXCEPT override final;

  /*! \brief Returns the allocation associated with unique id \em id
   */
  std::pair<pointer, allocation::map_t> id_to_pointer(persistent_allocation::unique_id_t id) BOOST_NOEXCEPT;

};


/*! \class file_allocation
 * \brief An allocation of memory in the kernel backed by a file on the filing system.
 * 
 * File allocations are similar to persistent allocations, except that their storage is kept
 * in a sparse file on the filing system and therefore will "survive" reboots (see below). The
 * intent of their usage is for very large allocations which would normally be refused to be backed
 * by the system page file, so if you need to allocate multiple gigabytes of memory far exceeding
 * available RAM, file_source is exactly the right thing to use. You should note:
 * 
 *  - Dirty pages are kept in memory as much as possible, and only actually flushed to the disk
 *    when there is insufficient RAM to store their contents anywhere else. By default the
 *    destroy_on_free flag is set in file_source, this will throw away any dirty pages instead of
 *    writing anything out on free and also deallocate any of that allocation which was flushed to
 *    disk, so ordinarily speaking the backing file consumes a minimal amount of disk space (see below)
 *    despite declaring itself to be many gigabytes in size. If you want to actually persist an
 *    allocation into the file, either use discard_on_free combined with calling flush(), or no flag
 *    to have the kernel lazily write out changes at its discretion on free.
 * 
 *  - When available the file is stored sparsely (supported by ext4, NTFS, HFS+, BTRFS), and if without
 *    sparse file support then with any compressed file support in the filing system (supported by ZFS).
 *    This means that only the pages flushed to disk due to insufficient RAM actually consume any disk
 *    space as those same pages are deallocated from the filing system on free. If your filing system
 *    does not support sparse files, zeroes are written instead which ought to compress very well and
 *    effectively achieve the same thing as sparse deallocation. Finally, if your filing system supports
 *    neither sparse files nor compressed files, you should take care to regularly delete the file
 *    as horrible fragmentation will occur - indeed, deleting the backing file before first use is
 *    generally always recommended, just be careful of races with any other concurrent users.
 * 
 *  - If you do persist allocations, you will need to retain their unique id and size across reboots.
 *    Again, you cannot resize an allocation if you wish to persist it across reboots.
 */
class BOOST_KERNELALLOC_DECL file_allocation : public allocation
{
public:
  //! \brief The type of a unique allocation id
  typedef unsigned long long unique_id_t;
protected:
  unique_id_t _unique_id;
  file_allocation(nonpersistent_source *p, size_type bytes);
public:
  virtual ~file_allocation() override final;
  
  virtual size_type map(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type map_prefault(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type unmap(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type discard(map_t *m, size_type no) BOOST_NOEXCEPT override final;
  virtual size_type destroy(map_t *m, size_type no) BOOST_NOEXCEPT override final;
    
  //! \brief The unique id of this persistent allocation within its source.
  unique_id_t unique_id() const BOOST_NOEXCEPT { return _unique_id; }

  //! \brief Resizes the allocation to a new size
  error_code resize(size_type newsize) BOOST_NOEXCEPT;
};

/*! \class file_source
 * \brief A source of kernel memory stored in a file on the filing system.
 */
class BOOST_KERNELALLOC_DECL file_source : public source
{
public:
  //! \brief A pointer to an allocation
  typedef rebind_pointer<file_allocation> pointer;
  //! \brief A const pointer to an allocation
  typedef const pointer const_pointer;
  //! \brief A native handle type
#ifdef WIN32
  typedef void *native_handle_type;
#else
  typedef int native_handle_type;
#endif
  
  //! \brief Constructs a file source of kernel memory.
  file_source(path name, flags_t flags=flags_t::destroy_on_free, size_type maximum=(size_type)-1, size_type remaining=(size_type)-1) : source(maximum, remaining) { }
  
  //! \brief Adopts a file source of kernel memory from an existing native file handle.
  file_source(native_handle_type handle, flags_t flags=flags_t::destroy_on_free, size_type maximum=(size_type)-1, size_type remaining=(size_type)-1) : source(maximum, remaining) { }
  
  //! \brief The name of this source, suitable for printing etc.
  virtual const char *name() BOOST_NOEXCEPT override final { return "file"; }
  
  /*! \brief Allocates at least \em bytes from the source, returning an empty pointer if unsuccessful
   */
  virtual expected<pointer, error_code> allocate(size_type bytes) BOOST_NOEXCEPT override final;

  //! \brief The native handle of the file backing this source
  native_handle_type native_handle() const BOOST_NOEXCEPT;
  
  //! \brief Detaches the native handle of the file backing this source from this source. The handle will no longer be used or closed on destruction.
  native_handle_type detach() BOOST_NOEXCEPT;
  
  /*! \brief Returns the allocation associated with unique id \em id
   */
  std::pair<pointer, allocation::map_t> id_to_pointer(persistent_allocation::unique_id_t id, size_type size) BOOST_NOEXCEPT;

};


/*! \class allocator
 * \brief A STL compatible allocator allocating memory from a kernel source
 */
template<class T> class allocator
{
  template<class A, class B> friend inline bool operator==(const allocator<A> &a, const allocator<B> &b) BOOST_NOEXCEPT;
  template<class A, class B> friend inline bool operator!=(const allocator<A> &a, const allocator<B> &b) BOOST_NOEXCEPT;
  
  source_ptr _source;
public:
  typedef T value_type;
  typedef T *pointer;
  typedef const pointer const_pointer;
  typedef T &reference;
  typedef const reference const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef std::true_type propagate_on_container_move_assignment;
  typedef std::false_type is_always_equal;
  template<class U> struct rebind { typedef allocator<U> other; };
  
  allocator() BOOST_NOEXCEPT { }
  allocator(source_ptr source) BOOST_NOEXCEPT : _source(source) { }
  allocator(const allocator &o) BOOST_NOEXCEPT : _source(o._source) { }
  allocator(allocator &&o) BOOST_NOEXCEPT : _source(std::move(o._source)) { }
  template<class U> allocator(const allocator<U> &o) BOOST_NOEXCEPT : _source(o._source) { }
  template<class U> allocator(allocator<U> &&o) BOOST_NOEXCEPT : _source(std::move(o._source)) { }
  pointer address(reference x) const BOOST_NOEXCEPT { return std::addressof(x); }
  const_pointer address(const_reference x) const BOOST_NOEXCEPT { return std::addressof(x); }
  pointer allocate(size_type n, std::allocator<void>::const_pointer hint=0)
  {
    if(!_source) throw std::invalid_argument("Unset source");
    if(n>max_size()) throw std::bad_alloc();
    size_type bytes=n*sizeof(T);
    auto a(_source->allocate(bytes));
    if(!a) throw std::system_error(a.error());
    // Probably he's just about to construct into this now, so prefault as a batch
    auto m(a->map_prefault());
    if(!m->addr) throw std::bad_alloc();
    return static_cast<pointer>(m->addr);
  }
  // Must accept any pointer from any source equally (STL requirements)
  void deallocate(pointer p, size_type n)
  {
    source_ptr source_;
    typename source::pointer allocation_;
    allocation::map_t map_;
    std::tie(source_, allocation_, map_)=source::locate_addr(p);
    if(!allocation_) throw std::invalid_argument("Address not found");
    allocation_->unmap(map_);
    if(map_.ec) throw std::system_error(m.ec, "Failed to unmap allocation");
  }
  size_type max_size() const BOOST_NOEXCEPT { return ((size_type)-1)/sizeof(T); }
  template<class U, class... Args> void construct(U *p, Args &&... args) { ::new(p) U(std::forward<Args>(args)...); }
  template<class U> void destroy(U *p) { p->~U(); }
};
template<class A, class B> inline bool operator==(const allocator<A> &a, const allocator<B> &b) BOOST_NOEXCEPT { return a._source==b._source; }
template<class A, class B> inline bool operator!=(const allocator<A> &a, const allocator<B> &b) BOOST_NOEXCEPT { return a._source!=b._source; }


// TODO: Free functions async_send() and async_receive() for sequences of allocation

// TODO: Free functions need to static_assert for trivial destructor of buffer type to
//       prevent write after send.

template<class Buffers, class CompletionToken, typename = typename
    std::enable_if<
      std::is_constructible<
        allocation,
        typename detail::is_container<Buffers>::type
      >::value
    >::type>
  typename asio::async_result<asio::handler_type_t<CompletionToken>, void(error_code, size_t)>>::type
  async_receive(Buffers n, CompletionToken &&token)
{
  
}

// TODO: Free functions for gather hashing and gather decrypt

template<class Buffers, class CompletionToken, typename = typename
    std::enable_if<
      std::is_constructible<
        allocation,
        typename detail::is_container<Buffers>::type
      >::value
    >::type>
  typename asio::async_result<asio::handler_type_t<CompletionToken>, void(error_code, size_t)>>::type
  async_aes128_read(Buffers n, CompletionToken &&token)
{
  
}

BOOST_KERNELALLOC_V1_NAMESPACE_END

#endif
